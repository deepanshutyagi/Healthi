pragma solidity ^0.4.4;



// This project is under development to create a permissioning system for the healthi platform
// @contract to grant and request permissions to access patient data

contract healthi {
    
//address of owner of the contract
    
    address public owner;
    
    
//Events to log details request generated by healthcare provider
//@access granted by the patient
//@registration status of healthcare provider and patient
    
    event requestGenerated (address from,address to,uint timestamp);
    event accessGranted (address from, address to, uint timestamp);
    event registrationComplete(address,uint id);
    
   
// Patient details on the chain
// @pid == patient id
// @patients account address on the chain
// @public key of the patient
    
    struct Patients {
        address patient;
        bytes32 publicKey;
        uint256 pid;
      
        
    }
   
// Used to count Number of patients registered and also used to provide a unique id
  
   uint256  numPatient;
   Patients[] Patient;
    
//healthcare provider details on the chain
//@hid == healthcare provider id
    
    struct healthProviders {
        address healthProv;
        bytes32 publicKey;
        uint256 hid;
        
    }
    
//Number of healthcare providers registered on the platform
  
   uint256 numHealthProviders;
   healthProviders[] healthProvider;
    
//mapping for accesstime granted by certain address to certain address
//@storing requests each time a request is made by healthcare provider to access patient data
   
    mapping (address=> mapping(address=>uint)) accessTime;
    mapping (address=> mapping(address=>bool)) requested;
    mapping (address=> mapping(address=>bool)) accessgranted;
    mapping (address => bool)  registered;
    
// constructor
    
    function healthi() {
        owner=msg.sender;
        numPatient=0;
        numHealthProviders=0;
    }
    
//Onlyonwner modifier, used to restrict access to certain functionalities
   
    modifier onlyOwner(){
        if (msg.sender!=owner) {
            revert();
        }
        _;
    }
    
// Register new patient using his public key and account address 
// Returns patient id if registration is successful
    
    function registerPatient(bytes32 _publickey,address _patient)  external  returns(uint _patientId,bool) {
        
        if (registered[_patient] == false) {
            numPatient += 1;
            _patientId = numPatient;
            Patient[_patientId].patient = _patient;
            Patient[_patientId].publicKey = _publickey;
            Patient[_patientId].pid = _patientId;
            registered[_patient] == true;
            registrationComplete(_patient,_patientId);
            return(_patientId,true);
        
        }else {
            revert();
        }

    }
    
    
// Only owner allowed to register new health provider is restricted to only owner
// Provide pregenerated address and public key of health provider    
    
    function registerHealthProvider(bytes32 _publickey,address _healthProv) onlyOwner   external returns (uint _healthProviderid) {

       
       if (registered[_healthProv]==false) { 
         numHealthProviders += 1;
         _healthProviderid = numHealthProviders;
         healthProvider[_healthProviderid].healthProv = _healthProv;
         healthProvider[_healthProviderid].publicKey = _publickey;
         healthProvider[_healthProviderid].hid = _healthProviderid;
         registered[_healthProv]==true;
         registrationComplete(_healthProv,_healthProviderid);
         return(_healthProviderid);
            
       } else {
           revert();
       }
        
       
    }

// Get patient's account address and publickey 
// Generally Healthproviders will need it to request access 
    
    function getPatientRecord(uint _patientId) external returns(address,bytes32) {
        return (Patient[_patientId].patient,Patient[_patientId].publicKey);


    }

// Get health providers account details
  
    function getHealthProviderRecord(uint _healthProviderid) public returns(address,bytes32) {

        return (healthProvider[_healthProviderid].healthProv,healthProvider[_healthProviderid].publicKey);

    }
    
    
//Access request from health institute made for patient
    
    function  requestAccess(address _patient,uint256 _time) external returns(bool) {
        if (registered[_patient] == true && registered[msg.sender]==true ) {
            if (requested[msg.sender][_patient] == false) {
                accessTime[msg.sender][_patient] = _time;
                requested[msg.sender][_patient] == true;
                requestGenerated(msg.sender,_patient,_time);
                return true;
            }
            
        } else {
            revert();
        }
        
    }
        
        
        
//Grantaccess to healthprovider
    
    function grantAccess(address _entity) external returns(bool) {
        if (registered[_entity]==true && registered[msg.sender]==true ) {
            if (requested[_entity][msg.sender]==true) {
                if (accessgranted[msg.sender][_entity ] == false) {
                     if (accessTime[msg.sender][_entity] == 0) {
                        
                        uint timeGiven = accessTime[_entity][msg.sender];
                        accessTime[msg.sender][_entity] = timeGiven;
                        
                        accessgranted[msg.sender][_entity] = true;
                        accessGranted(msg.sender,_entity,timeGiven);
                        return true;
                    }
                }
                
                
            }
        
        } else { 
            revert();
        
        }
        
        
    }
    
    

    
    
    
    
    
}